import { ContentTypeReaction, } from "@xmtp/content-type-reaction";
import { ContentTypeReply, } from "@xmtp/content-type-reply";
import { ContentTypeText } from "@xmtp/content-type-text";
import { filter } from "../core/filter.js";
import { ConversationContext } from "./ConversationContext.js";
export class MessageContext extends ConversationContext {
    #message;
    constructor({ message, conversation, client, }) {
        super({ conversation, client });
        this.#message = message;
    }
    usesCodec(codecClass) {
        return (this.#message.contentType?.sameAs(new codecClass().contentType) || false);
    }
    isText() {
        return filter.isText(this.#message);
    }
    isReply() {
        return filter.isReply(this.#message);
    }
    isReaction() {
        return filter.isReaction(this.#message);
    }
    isRemoteAttachment() {
        return filter.isRemoteAttachment(this.#message);
    }
    async sendReaction(content, schema = "unicode") {
        const reaction = {
            action: "added",
            reference: this.#message.id,
            referenceInboxId: this.#message.senderInboxId,
            schema,
            content,
        };
        await this.conversation.send(reaction, ContentTypeReaction);
    }
    async sendText(text) {
        await this.conversation.send(text, ContentTypeText);
    }
    async sendTextReply(text) {
        const reply = {
            reference: this.#message.id,
            referenceInboxId: this.#message.senderInboxId,
            contentType: ContentTypeText,
            content: text,
        };
        await this.conversation.send(reply, ContentTypeReply);
    }
    async getSenderAddress() {
        const inboxState = await this.client.preferences.inboxStateFromInboxIds([
            this.#message.senderInboxId,
        ]);
        return inboxState[0]?.identifiers[0]?.identifier;
    }
    get message() {
        return this.#message;
    }
}
//# sourceMappingURL=MessageContext.js.map